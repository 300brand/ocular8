#!/usr/bin/env python3
import argparse
import bson
import dateutil.parser
import logging
import lxml.etree
import pymongo
import urllib.request

logging.basicConfig(format='%(levelname).1s%(asctime)s.%(msecs)06d %(process)7d %(filename)s:%(lineno)d] %(message)s', datefmt='%m%d %H:%M:%S', level=logging.DEBUG)

def process(db, lexisnexis, xslt, dtd):
	parser = lxml.etree.XMLParser(dtd_validation=True, no_network=True, load_dtd=dtd)
	xslt_tree = lxml.etree.parse(xslt)
	transform = lxml.etree.XSLT(xslt_tree)
	xml_tree = lxml.etree.XML(lexisnexis['xml'], parser=parser)

	html_tree = transform(xml_tree)
	ns = {
		'lndocmeta': 'http://www.lexis-nexis.com/lndocmeta',
		'lnv':       'http://www.lexis-nexis.com/lnv',
		'lnvxe':     'http://www.lexis-nexis.com/lnvxe',
	}
	article = {
		'_id': lexisnexis['_id'],
		'islexisnexis': True,
		'lexisnexis': {
			'lni':     xml_tree.xpath('string(/NEWSITEM/lndocmeta:docinfo/lndocmeta:lnlni/@lnlni)', namespaces=ns),
			'smi':     xml_tree.xpath('string(/NEWSITEM/lndocmeta:docinfo/lndocmeta:smi/@lnsmi)', namespaces=ns),
			'dpsi':    xml_tree.xpath('string(/NEWSITEM/lndocmeta:docinfo/lndocmeta:dpsi/@lndpsi)', namespaces=ns),
			'section': xml_tree.xpath('string(/NEWSITEM/lnv:SECTION-INFO/lnvxe:position.section)', namespaces=ns),
		},
		'xml': lexisnexis['xml'],
		'html': lxml.etree.tostring(html_tree, encoding='UTF-8', method='html', doctype='<!DOCTYPE html>'),
	}

	check = db.articles.find_one({ 'lexisnexis.lni': article['lexisnexis']['lni'] })
	if check is not None:
		article['_id'] = check['_id']
		db.articles.save(article)
		return True

	pub_name = xml_tree.xpath('string(/NEWSITEM/lnv:PUB)', namespaces=ns)
	pub = db.pubs.find_one({ 'lexisnexis.name': pub_name })
	if pub is None:
		pub = {
			'_id': bson.objectid.ObjectId(),
			'name': pub_name,
			'islexisnexis': True,
			'lexisnexis': {
				'name':  pub_name,
				'track': None,
			},
		}
		db.pubs.insert(pub)

	section = article['lexisnexis']['section']
	if section == '':
		section = 'default'
	feed_url = 'http://www.lexis-nexis.com/{}/{}.xml'.format(pub['_id'], section.lower().strip().replace(' ', '_'))
	feed = db.feeds.find_one({ 'pubid': pub['_id'], 'url': feed_url })
	if feed is None:
		feed = {
			'_id':          bson.objectid.ObjectId(),
			'pubid':        pub['_id'],
			'url':          feed_url,
			'islexisnexis': True,
			'lexisnexis': {
				'track': None,
			},
		}
		db.feeds.insert(feed)
		db.pubs.update({ '_id': pub['_id'] }, { '$inc': { 'numfeeds': 1 } })

	if pub['lexisnexis']['track'] == False or feed['lexisnexis']['track'] == False:
		logging.warn('Not storing, Pub:%s, Feed:%s', pub['lexisnexis']['track'], feed['lexisnexis']['track'])
		return False

	article['pubid'] = pub['_id']
	article['feedid'] = feed['_id']
	db.articles.insert(article)

	return True


def main():
	parser = argparse.ArgumentParser(description='Extract meta info and content from articles using XPath')
	parser.add_argument('-mongo', help='MongoDB connection string', default='mongodb://localhost:27017/ocular8')
	parser.add_argument('-nsqdhttp', help='NSQd HTTP address', default='http://localhost:4151')
	parser.add_argument('-dtd', help='DTD location', default='newsitem.dtd')
	parser.add_argument('-xslt', help='XSLT location', default='newsitem.xslt')
	parser.add_argument('id', help='LexisNexis IDs', nargs='+')
	args = parser.parse_args()

	db = pymongo.MongoClient(args.mongo).get_default_database()
	bson_ids = [ bson.objectid.ObjectId(id) for id in args.id ]

	for id in bson_ids:
		lexisnexis = db.lexisnexis.find_one(id)
		if lexisnexis is None:
			logging.error('%s Article not found', id)
			continue

		if not process(db, lexisnexis, args.xslt, args.dtd):
			continue

		payload = str(lexisnexis['_id']).encode('utf-8')
		topic = 'article.id.extract.goose'
		nsqurl = '%s/pub?topic=%s' % (args.nsqdhttp, topic)
		try:
			logging.info("%s - %s" , nsqurl, payload)
			# urllib.request.urlopen(nsqurl, data=payload)
		except Exception as err:
			logging.error('%s Error while sending data to %s: %s', prefix, nsqurl, err)
		else:
			logging.info('Sent to %s', topic)

if __name__ == "__main__":
	main()
